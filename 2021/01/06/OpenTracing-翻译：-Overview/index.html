<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="google-site-verification" content="iHug-vHtQcv460XTpubJQX1Bv3Vg2PM_A8nn7D_O5J4" />
  <meta name="author" content="zchengsite, 1451426471@qq.com" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  
  <title>OpenTracing 翻译： Overview | iyea</title>

  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


  

<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="iyea" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/head.gif" alt="">
      
    </a>
    <div class="nickname"><a href="/">iyea</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">分类</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->



  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">OpenTracing 翻译： Overview</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="Update time"></i>
          2021-01-06
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="计算机">
                    <b>#</b> 计算机
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h3 id="OpenTracing-概览"><a href="#OpenTracing-概览" class="headerlink" title="OpenTracing 概览"></a>OpenTracing 概览</h3><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>微服务提供了强大的体系结构，但是仍然存在其他挑战，特别是调试和观察复杂网络中的分布式事务——简单的原因是没有调用栈。</p>
<p>这就是分布式追踪被需要之处，分布式追踪为描述和分析跨进程的事务提供了一个解决方案。分布式追踪的使用案例包括：异常检测（ anomaly detection ）、诊断稳态问题（ diagnosing steady state problems ）、分布式 profile （ distributed profiling ）、资源归因（ resource attribution ）、微服务的工作建模（ workload modeling of microservices ）。</p>
<h5 id="分布式追踪：一种心智模型（-Mental-Model-）"><a href="#分布式追踪：一种心智模型（-Mental-Model-）" class="headerlink" title="分布式追踪：一种心智模型（ Mental Model ）"></a>分布式追踪：一种心智模型（ Mental Model ）</h5><p>大多数追踪的模型都来自于 Google 的 Dapper 论文， OpenTracing 采用类似的术语：</p>
<ol>
<li>Trace ：事务在分布式系统中传播的描述；</li>
<li>Span ：表示一个带名字的、带起始 / 结束时间的具体操作， Span 接受描述具体业务信息的 k:v 格式的 tag ，和细粒度的、带时间戳的、结构化的 k:v 格式的 log ，它们可以附加到特定的 Span 实例上；</li>
<li>SpanContext ：服务上下游之间需要传递的 Trace 数据。 SpanContext 包含： Trace ID 、 Span ID 、以及任何其他的追踪系统或者业务逻辑需要传播到下游服务的数据；</li>
</ol>
<p><img src="https://iyea.github.io/images/2.png"></p>
<h5 id="四大块"><a href="#四大块" class="headerlink" title="四大块"></a>四大块</h5><p>现代软件系统如图所示：</p>
<p><img src="https://iyea.github.io/images/3.png"></p>
<p>现代软件系统的组件可以被分成 3 类：</p>
<ol>
<li>业务逻辑：您的代码；</li>
<li>库：其他人的代码；</li>
<li>服务：其他人的基础架构；</li>
</ol>
<p>这 3 个组件有不同的要求，并且影响着分布式追踪系统的设计。最终的设计有 4 个重要方面：</p>
<ol>
<li>追踪工具的 API ：装饰程序（ decorate ），例如 @trace ；</li>
<li>网络传播协议：在 RPC 请求中，需要和应用程序数据一起发送的内容；</li>
<li>数据协议：异步地发送到分析系统的内容；</li>
<li>分析系统：用于处理跟踪数据的数据库和交互式 UI ；</li>
</ol>
<h5 id="OpenTracing-是如何做的？"><a href="#OpenTracing-是如何做的？" class="headerlink" title="OpenTracing 是如何做的？"></a>OpenTracing 是如何做的？</h5><p>OpenTracing API 提供了一个标准的、供应商中立（ vendor neutral ）的工具框架。这就意味着：如果一个开发者想要尝试使用各种不同的分布式追踪系统，那么开发人员可以简单地更改 Tracer 的配置，而不必为新的分布式追踪系统重复构建整个环境。</p>
<h3 id="什么是分布式追踪？"><a href="#什么是分布式追踪？" class="headerlink" title="什么是分布式追踪？"></a>什么是分布式追踪？</h3><p>分布式追踪，也被称为分布式请求追踪，是一个用于 profile 和监控应用程序的方法，特别适用于微服务架构的应用程序。分布式追踪有助于查明哪里发生了故障，以及是什么导致的性能下降。</p>
<h5 id="谁使用分布式追踪？"><a href="#谁使用分布式追踪？" class="headerlink" title="谁使用分布式追踪？"></a>谁使用分布式追踪？</h5><p>IT 和 DevOps 团队可以使用分布式追踪来监控应用程序。分布式追踪特别适合 debug 和监控现代的分布式软件架构（例如微服务）。</p>
<p>Dev 可以使用分布式追踪来帮助 debug 和优化代码。</p>
<h5 id="什么是-OpenTracing-？"><a href="#什么是-OpenTracing-？" class="headerlink" title="什么是 OpenTracing ？"></a>什么是 OpenTracing ？</h5><p>从否定的方面来理解 OpenTracing 可能更容易：</p>
<ul>
<li>OpenTracing 不是一个下载包或者程序。 OpenTracing 需要软件工程师向应用程序或者应用程序使用的框架中添加探测工具代码。</li>
<li>OpenTracing 不是标准。 OpenTracing API 项目正在努力地为分布式追踪创建更多标准化的 API 和探测工具。</li>
</ul>
<p>OpenTracing 由 API 规范、实现该 API 规范的框架和 lib 库、以及文档组成。 OpenTracing 让开发者不会被锁定在任何特定的产品或厂商的 API ，向自己的代码中添加 trace 功能。</p>
<p>有关 OpenTracing 实现的更多信息，请参考支持 OpenTracing 规范的语言列表和 tracer 列表。</p>
<h5 id="概念和术语"><a href="#概念和术语" class="headerlink" title="概念和术语"></a>概念和术语</h5><p>所有特定语言的 OpenTracing API 都共享一套核心的概念和术语。这些概念非常重要、非常重要，重要得以至于有自己的代码库 github.com/opentracing/specification 。</p>
<ol>
<li>OpenTracing 的语义规范是当前泛语言（ pan-language ）的 OpenTracing 标准的描述。</li>
<li>语义约定描述了常见语义场景下的 Span tags 和 log keys 。</li>
</ol>
<p>这些文件都在 Github repo 上版本控制。</p>
<h3 id="Spans"><a href="#Spans" class="headerlink" title="Spans"></a>Spans</h3><h5 id="什么是-Span-？"><a href="#什么是-Span-？" class="headerlink" title="什么是 Span ？"></a>什么是 Span ？</h5><p>Span 是分布式追踪的主要构建模块，表示分布式系统中的一个独立的工作单元，代表一个有名字的、有时间的操作。</p>
<p>Span 可以（并且通常）包含对其他 Span 的指向，这允许将多个 Span 组装到一个完整的 Trace 中（ Trace ：在分布式系统中请求传播的描述）。</p>
<p>每一个 Span 根据 OpenTracing 规范，被封装成以下的结构：</p>
<ul>
<li>操作的名字</li>
<li>开始和结束的时间戳</li>
<li>k : v 格式的 Span tags 的集合</li>
<li>k : v 格式的 Span logs 的集合</li>
<li>SpanContext</li>
</ul>
<h5 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h5><p>Tags 是 k : v 格式的、允许用户自定义的、对于一个 Span 的标注，可以方便用户查询、过滤、理解追踪数据。在 semantic_conventions.md 中，列出了常见场景的、常规的 Span tags 。一个例子是：</p>
<ul>
<li>Tag key 是 db.instance ，表示用于标识一个数据库主机；</li>
<li>Tag key 是 http.status_code ，表示 HTTP 请求的响应码；</li>
<li>Tag key 是 error ，表示一个操作是否成功；</li>
</ul>
<h5 id="Logs"><a href="#Logs" class="headerlink" title="Logs"></a>Logs</h5><p>Logs 是 k : v 格式的，用于记录在当前 Span 中发生的特定事件的 log 信息。</p>
<h5 id="SpanContext"><a href="#SpanContext" class="headerlink" title="SpanContext"></a>SpanContext</h5><p>SpanContext 携带了跨进程通信的数据。具体来说，它有两个部分：</p>
<ul>
<li>依赖于具体实现的、在一个 Trace 中的某一个 Span 的唯一标识，例如， spanID 和 traceID 。</li>
<li>Baggage Items ，这些 k : v pair 是跨进程的，可以持有一些对整个追踪链都可见的数据。</li>
</ul>
<p><img src="https://iyea.github.io/images/4.png"></p>
<h3 id="Scopes-和-Threading"><a href="#Scopes-和-Threading" class="headerlink" title="Scopes 和 Threading"></a>Scopes 和 Threading</h3><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>在任何一个线程中，都有一个 active 的 Span ，表示正在运行的操作，被称为 ActiveSpan 。 OpenTracing API 仅仅允许线程中：在一个时刻，只有一个 Span 是 active 状态的。这是使用 Scope 来管理的， Scope 决定了一个 Span 的激活或者取消激活的状态。</p>
<p>其他的 Span 将满足如下状态之一：</p>
<ul>
<li>Started</li>
<li>Not finished</li>
<li>Not active</li>
</ul>
<p>举个例子，一个线程中可以有多个 Span （但是都不是 avtive 状态的），这些 Span 有可能：</p>
<ul>
<li>等待 IO</li>
<li>等待 child Span 返回</li>
<li>关闭了关键的路径（ Off of the critical path ）</li>
</ul>
<p>注意：如果开发者创建一个新的 Span 时， Scope 已经存在，那么这个 Scope 将成为 Span 的 parent ，除非开发者在 buildSpan() 时调用 ignoreActiveSpan() ，或者显式地指定 parent context 。</p>
<h5 id="访问当前的-Active-Span"><a href="#访问当前的-Active-Span" class="headerlink" title="访问当前的 Active Span"></a>访问当前的 Active Span</h5><p>由于在 function-to-function 之间手动地传递 Span 不是很方便，因此 OpenTracing 要求每一个 Tracer 都包含一个 ScopeManager ， ScopeManager API 允许通过 Scope 访问 active Span 。</p>
<h5 id="跨线程移动-Span"><a href="#跨线程移动-Span" class="headerlink" title="跨线程移动 Span"></a>跨线程移动 Span</h5><p>使用 ScopeManager API ，开发人员可以在不同的线程之间移动 Span ， Span 的生命周期可能开始于一个线程，但是结束于另一个线程。 ScopeManager API 允许将 Span 传递给另一个线程或者 callback ，但是 Scope 不支持被如此传递。更多信息请参考具体语言的文档。</p>
<h3 id="Tags-、-logs-和-Baggage-Items"><a href="#Tags-、-logs-和-Baggage-Items" class="headerlink" title="Tags 、 logs 和 Baggage Items"></a>Tags 、 logs 和 Baggage Items</h3><h5 id="Tags-1"><a href="#Tags-1" class="headerlink" title="Tags"></a>Tags</h5><p>Tags 是 k : v 格式的、允许用户自定义的、对于一个 Span 的标注，可以方面用户查询、过滤、理解追踪数据。在 semantic_conventions.md 中，列出了常见场景的、常规的 Span tags 。一个例子是：</p>
<ul>
<li>Tag key 是 db.instance ，表示用于标识一个数据库主机；</li>
<li>Tag key 是 http.status_code ，表示 HTTP 请求的响应码；</li>
<li>Tag key 是 error ，表示一个操作是否成功；</li>
</ul>
<h5 id="Logs-1"><a href="#Logs-1" class="headerlink" title="Logs"></a>Logs</h5><p>Logs 是 k : v 格式的，用于记录在当前 Span 中发生的特定事件的 log 信息。</p>
<h5 id="Baggage-Items"><a href="#Baggage-Items" class="headerlink" title="Baggage Items"></a>Baggage Items</h5><p>SpanContext 携带了跨进程通信的数据。具体来说，它有两个部分：</p>
<ul>
<li>依赖于具体实现的、在一个 Trace 中的某一个 Span 的唯一标识，例如， spanID 和 traceID 。</li>
<li>Baggage Items ，这些 k : v pair 是跨进程的，可以持有一些对整个追踪链都可见的数据。</li>
</ul>
<h3 id="Tracers"><a href="#Tracers" class="headerlink" title="Tracers"></a>Tracers</h3><h5 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h5><p>OpenTracing 提供了一个开放的、与供应商无关的标准 API ，用于描述分布式事务，尤其是因果关系、语义、和时间。它提供了一个通用的分布式上下文传播框架，由以下 API 组成：</p>
<ul>
<li>在进程之间传递 metadata context</li>
<li>编码和解码 metadata context ，为了在网络连接的进程之间通信</li>
<li>因果关系追踪： parent-child 、 forks 、 joins</li>
</ul>
<p>OpenTracing 消除了不同的 tracer 之间的差异。这意味着无论开发者使用的 tracer 系统是什么，接口都将保持不变。为了使用 OpenTracing 规范对程序进行检测，必须部署兼容 OpenTracing 的 tracer 。</p>
<h5 id="Tracer-接口"><a href="#Tracer-接口" class="headerlink" title="Tracer 接口"></a>Tracer 接口</h5><p>Tracer 接口创建 Span 并且理解如何去跨进程地注入（ Inject ，序列化）和 提取（ Extract ，反序列化） metadata 数据，它具有以下功能：</p>
<ul>
<li>start 一个新的 Span</li>
<li>注入（ Inject ） SpanContext 到一个载体（ carrier ）</li>
<li>从一个载体（ carrier ）中提取（ Extract ） SpanContext</li>
</ul>
<p>以上接口，下面会详细介绍。</p>
<h5 id="设置-Tracer"><a href="#设置-Tracer" class="headerlink" title="设置 Tracer"></a>设置 Tracer</h5><p>Tracer 是记录 Span 、并且把 Span 传递到某处的具体实现。应用程序如何处理 Tracer 取决于开发人员：直接在整个应用程序中使用它、或者把它存储到 GlobalTracer 中，以便和其他检测框架一起使用。</p>
<p>不同的 Tracer 实现，在初始化的时，传递的参数是不同的，例如：</p>
<ul>
<li>应用程序追踪的组件名称</li>
<li>追踪终端</li>
<li>追踪证书</li>
<li>抽样策略</li>
</ul>
<p>当 Tracer 实例获取到之后，就可以用 Tracer 来手动创建 Span ，或者把它传递给框架、库，等现有的探测工具。</p>
<p>为了不强迫用户手动维护 Tracer ， io.opentracing.util 组件提供了实现 io.opentracing.Tracer 接口的一个帮助类 GlobalTracer ，作为一个全局的、可以在任何地方拿到的 Tracer 实例。它将所有的操作都转发到另一个基础的 Tracer 。</p>
<p>默认情况下， Tracer 是 no-nop 实现。</p>
<h5 id="开始一个新的-Trace"><a href="#开始一个新的-Trace" class="headerlink" title="开始一个新的 Trace"></a>开始一个新的 Trace</h5><p>当一个 Span 创建出来，并且没有指定 parent Span 时，一个新的 trace 开始了。当创建一个 Span 时，你需要指定一个『操作名称』，这个操作名称是无格式的字符串，可以帮助确定该 Span 相关的代码。在这个新的 trace 中，下一个 Span 可能是一个 child Span ，表示 main Span 的子调用。因此， child Span 与 main Span 有一个 Childof 的关系。另一种关系是 FollowsFrom ，这时，新的 Span 独立于 parent Span ，例如一个异步调用。</p>
<h5 id="访问-Active-Span"><a href="#访问-Active-Span" class="headerlink" title="访问 Active Span"></a>访问 Active Span</h5><p>Tracer 可以被用来访问 ActiveSpan ，在某些语言的 API 中， ActiveSpan 也可以通过 ScopeManager 拿到。</p>
<h5 id="通过-Inject-和-Extract-来传播-Trace"><a href="#通过-Inject-和-Extract-来传播-Trace" class="headerlink" title="通过 Inject 和 Extract 来传播 Trace"></a>通过 Inject 和 Extract 来传播 Trace</h5><p>为了追踪跨进程的分布式系统，服务端需要能够继续追踪客户端通过请求注入（ Inject ）的那个 trace 。 OpenTracing 通过提供 Inject 和 Extract 接口来实现这个需求。 Inject 方法允许将 SpanContext 传递给载体（ carrier ），例如，将跟踪信息传递到客户端的请求里，这样服务端就能继续追踪这个 trace 。 Extract 和 Inject 方法相反，如果（在 server 端的视角）客户端有一个 active 的请求，开发者必须使用 io.opentracing.Tracer.extract 提取 SpanContext 。</p>
<p><img src="https://iyea.github.io/images/5.png"></p>
<h3 id="Inject-和-Extract"><a href="#Inject-和-Extract" class="headerlink" title="Inject 和 Extract"></a>Inject 和 Extract</h3><p>开发者想要添加跨进程的追踪支持，必须要了解 Tracer.Inject(…) 和 Tracer.Extract(…) 功能。它们在概念上很强大，允许开发者编写正确的、通用的跨进程传播代码，而不必绑定到特定的 OpenTracing 实现。</p>
<p>无论特定的 OpenTracing 语言或者 OpenTracing 实现如何，本文档都会简要介绍 Inject 和 Extract 的设计以及正确使用。</p>
<h5 id="显式-trace-传播的『大图景』"><a href="#显式-trace-传播的『大图景』" class="headerlink" title="显式 trace 传播的『大图景』"></a>显式 trace 传播的『大图景』</h5><p>分布式追踪最难的地方就是分布式的部分。任何追踪系统都需要一个方法来了解不同进程之间的因果关系，无论这些流程是通过 RPC 框架、发布订阅系统、消息队列、 HTTP 调用、 UDP 数据包，还是其他的方式进行连接。</p>
<p>某些分布式追踪系统（例如 2003 年的 Project5 和 2006 年的 WAP5 和 2014 年的 Mystery Machine ）『推理』跨进程的因果关系。当然，在这些黑匣子推理方法的『方便性』和『 trace 质量』之间，有一个 tradeoff 。出于对质量的关注， OpenTracing 是一个明确的分布式追踪标准， OpenTracing 与 2007 年的 X-Trace 、 2010 年的 Dapper 、以及其他的开源追踪系统例如 Zipkin 、 Jaeger 更加对齐（而不是基于推理的黑匣子）。</p>
<p>综合来看， Inject 和 Extract 允许进程之间的 trace 传播，而无需耦合于特定的 OpenTracing 实现。</p>
<h5 id="OpenTracing-传播方案的需求"><a href="#OpenTracing-传播方案的需求" class="headerlink" title="OpenTracing 传播方案的需求"></a>OpenTracing 传播方案的需求</h5><p>为了使得 Inject 和 Extract 发挥作用，必须满足以下条件：</p>
<ul>
<li>OpenTracing 的用户在处理跨进程的 trace 传播时，不必编写特定于 OpenTracing 实现的代码</li>
<li>OpenTracing 实现不必为每种已知的进程之间的通讯方式做特殊处理</li>
<li>传播机制可以扩展</li>
</ul>
<h5 id="基本方法：-Inject-、-Extract"><a href="#基本方法：-Inject-、-Extract" class="headerlink" title="基本方法： Inject 、 Extract"></a>基本方法： Inject 、 Extract</h5><p>一个 trace 中的任何 SpanContext 可以被注入到 OpenTracing 称之为 Carrier 的地方。 Carrier 是一种接口或者数据结构，可以用于进程之间的通信，也就是说， Carrier 是将追踪的状态从一个进程带到另一个进程的东西。 OpenTracing 包括了两种必须的 Carriers 格式，用户也可以自定义 Carriers 格式。 </p>
<p>类似地，给定一个 Carrier ，一个被注入的 trace 可以通过 Extracted 方法生成一个 SpanContext 实例，该实例在语义上，与（之前）被注入到 Carrier 中的 SpanContext 相同。</p>
<p>Inject 伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">span_context &#x3D; ...</span><br><span class="line">outbound_request &#x3D; ...</span><br><span class="line"></span><br><span class="line"># 我们使用 buildin 的 HTTP_HEADERS carrier 格式</span><br><span class="line"># 在调用 Inject 之前，创建出来一个空的 map 作为 carrier</span><br><span class="line">carrier &#x3D; &#123;&#125;</span><br><span class="line">tracer.Inject(span_context, opentracing.Format.HTTP_HEADERS, carrier)</span><br><span class="line"></span><br><span class="line"># 现在， carrier 包含 k:v pairs ，我们可以使用任何的协议传输它们</span><br><span class="line">for k, v in carrier:</span><br><span class="line">    outbound_requerst.headers[k] &#x3D; escape(v)</span><br></pre></td></tr></table></figure>

<p>Extract 伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inbound_request &#x3D; ...</span><br><span class="line"></span><br><span class="line"># 我们仍然使用 buildin 的 HTTP_HEADERS carrier 格式</span><br><span class="line"># 我们可以使用包含无关数据的 k:v pairs ， OpenTracing 的实现会从中查找所需的字段</span><br><span class="line"># 因此， inbound_request.headers 可以直接作为 carrier</span><br><span class="line">carrier &#x3D; inbound_request.headers</span><br><span class="line">span_context &#x3D; tracer.extract(opentracing.Format.HTTP_HEADERS, carrier)</span><br><span class="line"></span><br><span class="line"># 继续这个 trace</span><br><span class="line">span &#x3D; tracer.start_span(&quot;...&quot;, child_of&#x3D;span_context)</span><br></pre></td></tr></table></figure>

<p>Carriers 是有格式的，在某些 OpenTracing 语言中，格式必须是常量或者是 string ，在其他语言中，可以自行推断。</p>
<h5 id="Carriers-格式"><a href="#Carriers-格式" class="headerlink" title="Carriers 格式"></a>Carriers 格式</h5><p>至少，所有的平台都需要支持两种 carrier 格式： Text map 和 Binary 。</p>
<p>Text map 格式是常用的 string : string 的映射格式。</p>
<p>Binary 格式的 Carriers 是不透明（不可读）的字节数组，更加紧凑高效。</p>
<p>OpenTracing 的实现可以选择在 Carriers 里面存储哪些数据，这些不是由 OpenTracing 规范定义的，例如 Dapper 的 SpanContext 包含一个 traceID ，一个 spanID ，以及一个表示采样状态的位图。</p>
<h5 id="OpenTracing-跨进程的互通性"><a href="#OpenTracing-跨进程的互通性" class="headerlink" title="OpenTracing 跨进程的互通性"></a>OpenTracing 跨进程的互通性</h5><p>不能期望不同的 OpenTracing 能够以兼容的方式提供 Inject 和 Extract 。尽管 OpenTracing 要求：整个分布式系统对于分布式追踪的实现是不感知的，但是为了能让进程之间成功通信，传播的双方都使用同一种 OpenTracing 实现是至关重要的。</p>
<h5 id="自定义-Inject-Extract-Carrier-格式"><a href="#自定义-Inject-Extract-Carrier-格式" class="headerlink" title="自定义 Inject/Extract Carrier 格式"></a>自定义 Inject/Extract Carrier 格式</h5><p>任何传播子系统（ RPC 、 MQ ，等等）都可以选择引入自定义的 Inject/Extract 格式，但需要在代码层面上兼容 OpenTracing 默认的格式（即， try 里面尝试自定义格式， except 里面用 OpenTracing 的默认格式）。</p>
<p>假设我们是 ArrrPC 的作者，我们想添加 OpenTracing 支持出站请求，伪代码类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">span_context &#x3D; ...</span><br><span class="line">outbound_request &#x3D; ...</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    tracer.Inject(span_context, arrrpc.ARRRPC_OT_CARRIER, outbound_request)</span><br><span class="line">except opentracing.UnsupportedFormatException:</span><br><span class="line">    carrier &#x3D; &#123;&#125;</span><br><span class="line">    tracer.Inject(span_context, opentracing.Format.HTTP_HEADERS, carrier)</span><br><span class="line">    </span><br><span class="line">    for k, v in carrier:</span><br><span class="line">        outbound_request.headers[k] &#x3D; escape(v)</span><br></pre></td></tr></table></figure>

<h5 id="更多关于自定义-Carrier-格式的内容"><a href="#更多关于自定义-Carrier-格式的内容" class="headerlink" title="更多关于自定义 Carrier 格式的内容"></a>更多关于自定义 Carrier 格式的内容</h5><p>不同的平台之间，对于 Carrier 格式的表示可能有所不同。对于运营商自定义的新的 Carrier 格式，必须满足的一点是『不需要更改核心的 OpenTracing API 』。如果 ArrrPC 框架的作者想要定义 Carrier 的格式，则他必须要能做到『不把 PR 提交给 OpenTracing 实现的提供者』。</p>
<h5 id="端到端的-Inject-Extract-传播例子"><a href="#端到端的-Inject-Extract-传播例子" class="headerlink" title="端到端的 Inject/Extract 传播例子"></a>端到端的 Inject/Extract 传播例子</h5><p>为了使得上述更加具体，以下是一个例子：</p>
<ul>
<li>客户端程序 start 一个 Span ，并且将通过 HTTP 协议进行 RPC</li>
<li>客户端程序调用 Tracer.Inject(context=Span.Context, format=HTTP_HEADERS, carrier=request.headers)</li>
<li>Inject 方法对 SpanContext 编码，塞到即将要发送的请求的 HTTP Headers 中</li>
<li>HTTP 请求发送，数据跨越了进程边界……</li>
<li>服务器进程调用 Tracer.Extract(format=HTTP_HEADERS, carrier=request.headers) ，从请求中提取 SpanContext</li>
<li>在没有数据损坏和其他错误的情况下，服务器现在具有一个 SpanContext 实例，该实例与客户端中的 trace 属于同一个 trace</li>
</ul>

      </div>
      
    </div>
    

    
      <div class="comments-container">
        





      </div>
    
  </div>


      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



      


    </div>
  </body>
</html>
